## 延迟函数调用

当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的[退出阶段](https://gfw.go101.org/article/function-declarations-and-calls.html#exiting-phase)后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。

每个协程维护着两个调用堆栈。

- 一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。
- 另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。

下面是另一个略微复杂一点的使用了延迟调用的例子程序。此程序将按照自然数的顺序打印出0到9十个数字。

```go
package main

import "fmt"

func main() {
	defer fmt.Println("9")
	fmt.Println("0")
	defer fmt.Println("8")
	fmt.Println("1")
	if false {
		defer fmt.Println("not reachable")
	}
	defer func() {
		defer fmt.Println("7")
		fmt.Println("3")
		defer func() {
			fmt.Println("5")
			fmt.Println("6")
		}()
		fmt.Println("4")
	}()
	fmt.Println("2")
	return
	defer fmt.Println("not reachable")
}
```

### 协程和延迟调用的实参的估值时刻

一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说，

- 对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。
- 对于一个协程调用，它的实参是在此协程被创建的时候估值的。

- 一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟/协程调用。

一个例子：

```go
package main

import "fmt"

func main() {
	func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
}
```

运行上述代码，将得到如下结果：

```
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
```



笔记：

这里之所以显示的结果是210 333而不是210 210的原因在于下面这句话，也就是开头提到的：

“当一个函数调用被延迟后，它不会立即被执行。它将被推入由**当前协程**维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的[退出阶段](https://gfw.go101.org/article/function-declarations-and-calls.html#exiting-phase)后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。“

注意这里的加粗字段：当前写成，也就是说是在一个func的范围内，在这个func内的延迟调用堆栈中的函数调用逆序执行完毕之后才推出当前函数。然后我们在利用上面提及的一个知识点：

- 对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。

所以i = 0、1、2随延迟函数被依次推入

```go
func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
```

这第一个匿名函数中的延迟调用函数会在当前匿名函数维护的延迟调用堆栈中逆序执行，因此先打印结果：2 1 0



下面再来看下面一段代码为什么输出：3 3 3

```go
func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
```

首先最外层由一个匿名函数包裹，然后延迟调用的函数又是一个匿名函数，这里就需要注意上面提及的另一个概念了：

- 一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟/协程调用。

我们分析：每循环一次，i加一的同时延迟函数被推入延迟调用堆栈中，那么，这些言辞函数的什么时候被估值呢？从上面这个概念我们就可以推出：因为匿名函数内部表达式是在匿名函数被执行的时候才被估值的，因此，前面三次循环的i值并没有被估进来，当延迟调用堆栈中的延迟函数开始逆序执行时候，此时的i值为3,因此这三个延迟匿名函数被估的值都是3。因此输出结果：3 3 3