package main

/*内置的error是接口类型。error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。
对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。
通常，当函数返回non-nil的error时，其它的返回值是未被定义的，这些未定义的返回值应该被忽略。然而，有
少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数
以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。*/

/*常用的五种错误处理方式：
1：传播错误：fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。
当错误最终由main函数处理时，错误信息应提供清晰的从错误到后果的因果链。
2：重新尝试失败的操作
3：输出错误信息并结束程序，需要注意的是这种策略只应该在main中执行。对于库函数而言，应仅仅向上传播错误，除非该错误意味着程序
内部包含不一致性，即遇到了bug，才能在库函数中结束程序。os.Exit(1)， 调用log.Fatalf可以更简洁的代码达成输出错误信息的效果，
log中的所有函数，都默认会在错误信息之前输出时间信息。我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名
log.SetPrefix("wait: ")
log.SetFlags(0)
4：有时我们只需要输出错误信息即可，不必中断程序的运行，我们可以通过log包的函数或者标准错误流输出错误信息。
fmt.Fprintf(os.Stderr, "ping failed :%v; networking disabled\n", err)
log包中的所有函数会为没有换行符的字符串增加换行符
5：直接忽略掉错误。
*/
